;defines functions for dealing with the idea of 'context'
;we spend a lot of time traversing a certain tree of labels
;we want to easily be able to specify certain pieces of the tree 
;and know 'where we are' in the tree at a given moment. This is what context is for 

;formally, a context is a list {layer {c {c1 i0} {c2 i1} {c3 i2} ... {r i_(n-1)}}}
;where it is specified that all the labels will come from the layer name layer
;and c is a label name such that c is the i0th child of c1, c1 is a label name
;such that it is the i1th child of c2,and so on and so forth. 
;Within this context, we do not know about r's parent so we say that r is the root. 

define function make-context-from(layer, root)
 begin
    return list(layer, list(root))
 end

define function advance-context-to-ith-child(i, context)
 begin
    set layer = nth(0, context)
	set cur-root = nth(0, nth(1, context))
	set label-object = find-label(layer, cur-root)
	set containment = extract-containment(label-object)
	set new-second-element = list(nth(0, nth(1, context)), i)
	set new-context-list = cons(nth(i, containment), cons(new-second-element, rest(nth(1, context)))
	return cons(layer, new-context-list)
 end


;we also have the notion of a context-decider
;this is an object that will 'accept' some contexts and 'reject' others
;these are very useful because we wish to specify during which contexts certain
;sound events have certain parameters 



;accepts all contexts that are contained within the tree starting at label
;in case it is not clear, this just means that the root to leaf path STARTS at label
;(and is contained within layer)
define function make-contain-context-decider(layer, label)
 begin
	return list("contain", layer, label)
 end

;accepts all contexts that finish at label
;i.e. the root to leaf path ENDS at label (and is contained within layer)
define function make-point-context-decider(layer, label)
 begin
	return list("point", layer, label)
 end


define function make-OR-context-decider(decider1, decider2)
 begin
	return list("or", decider1, decider2)
 end

;or together a list of context deciders
;NOTE: decider-list cannot be nil (I don't feel like implementing the always yes decider)
define function accumulate-context-decider-or(decider-list)
 begin
	if length(decider-list) = 1 then return nth(0, decider-list)
	return make-OR-context-decider(accumulate-context-decider-or(rest(decider-list)), nth(0, decider-list))
 end

define function make-AND-context-decide(decider1, decider2)
 begin
	return list("and", decider1, decider2)
 end

define function make-NOT-context-decider(decider)
 begin
	return list("not", decider)
 end


;accept or reject the context based on the context-decider 
 define function decide(context, context-decider)
  begin
	 if nth(0, context-decider) = "contain" then 
	  begin
		return nth(0, context) = nth(1, context-decider) & nth(0, reverse(context)) = nth(2, context-decider)
	  end
	else if nth(0, context-decider) = "point" then
	 begin
		return nth(0, context) = nth(1, context-decider) & nth(0, nth(1, context)) = nth(2, context-decider)
	 end
	else if nth(0, context-decider) = "or" then 
	 begin
		return decide(context, nth(1, context-decider)) | decide(context, nth(2, context-decider))
	 end
	else if nth(0, context-decider) = "and" then 
	 begin
		return decide(context, nth(1, context-decider)) & decide(context, nth(2, context-decider))
	 end
	else if nth(0, context-decider) = "not" then
	 begin
		return !decide(context, nth(1, context-decider))
	 end
	print("warning: unimplemented context-decider was forced to make a decision")
  end